<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>TDEP 使用手册（统一脚本版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      font-size: 16px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans SC", sans-serif;
      background: #f5f5f7;
      color: #222;
      line-height: 1.6;
    }

    .page {
      max-width: 960px;
      margin: 0 auto;
      padding: 1.5rem 1rem 2.5rem;
    }

    header {
      text-align: center;
      margin-bottom: 1.5rem;
    }

    header h1 {
      font-size: clamp(1.6rem, 3vw, 2.2rem);
      margin: 0.2rem 0;
    }

    header p {
      margin: 0.2rem 0;
      color: #666;
      font-size: 0.9rem;
    }

    .card {
      background: #fff;
      border-radius: 0.9rem;
      padding: 1.25rem 1.35rem;
      margin-bottom: 1rem;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.06);
      border: 1px solid rgba(148, 163, 184, 0.25);
    }

    h2 {
      font-size: 1.1rem;
      margin: 0 0 0.6rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    h2 span.step {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1.6rem;
      height: 1.6rem;
      border-radius: 999px;
      background: #1d4ed8;
      color: #fff;
      font-size: 0.85rem;
      flex-shrink: 0;
    }

    h2 small {
      font-weight: 500;
      color: #555;
    }

    p {
      margin: 0.2rem 0 0.5rem;
      font-size: 0.95rem;
    }

    ul, ol {
      padding-left: 1.2rem;
      margin: 0.3rem 0 0.6rem;
    }

    li {
      margin: 0.15rem 0;
      font-size: 0.95rem;
    }

    code.inline {
      padding: 0.1rem 0.35rem;
      border-radius: 0.4rem;
      background: #e5e7eb;
      font-family: "JetBrains Mono", SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
    }

    pre {
      margin: 0.4rem 0 0.2rem;
      padding: 0.75rem 0.8rem;
      border-radius: 0.7rem;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.8rem;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    pre code {
      font-family: "JetBrains Mono", SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre;
    }

    details {
      margin-top: 0.3rem;
      border-radius: 0.7rem;
      background: #f1f5f9;
      padding: 0.3rem 0.7rem 0.5rem;
    }

    details summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.9rem;
      font-weight: 500;
      color: #1f2937;
      padding: 0.35rem 0;
    }

    details[open] summary {
      border-bottom: 1px dashed #cbd5f5;
      margin-bottom: 0.25rem;
    }

    details summary::before {
      content: "▶";
      display: inline-block;
      font-size: 0.7rem;
      transition: transform 0.15s ease;
      color: #4b5563;
    }

    details[open] summary::before {
      transform: rotate(90deg);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.08rem 0.4rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 500;
      background: #eff6ff;
      color: #1d4ed8;
      border: 1px solid rgba(37, 99, 235, 0.2);
      margin-left: 0.3rem;
    }

    .meta {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      font-size: 0.8rem;
      color: #6b7280;
      margin-top: 0.4rem;
    }

    .meta span {
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: #e5e7eb;
    }

    .footer {
      text-align: center;
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 1.5rem;
    }

    @media (min-width: 768px) {
      .page {
        padding: 2rem 1.5rem 3rem;
      }

      .card {
        padding: 1.4rem 1.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>TDEP 使用手册（统一脚本版）</h1>
      <p>用一个 bash 脚本一次性生成 TDEP 所需 7 个 infile.*，再完成打包和后处理</p>
      <div class="meta">
        <span>written by<code class="inline"> qhwu </code></span>
        <span>环境：VASP + TDEP</span>
        <span>示例温度：600 K</span>
      </div>
    </header>

    <!-- 目录与输入假设 -->
    <section class="card">
      <h2>
        <span class="step">0</span>
        目录与输入假设
      </h2>
      <p>默认在 <code class="inline">runs/</code> 目录下，每个子目录是一次 VASP 单点计算，命名不作强制要求（可以是 <code class="inline">frame_0001</code>、<code class="inline">0001</code>、<code class="inline">vasp-0001</code> 等）。</p>
      <pre><code>runs/
  0001/       POSCAR  OUTCAR(.gz)
  0002/       POSCAR  OUTCAR(.gz)
  vasp-0003/  POSCAR  OUTCAR(.gz)
  ...
</code></pre>
      <ul>
        <li>每个子目录下必须包含：<code class="inline">POSCAR</code> 和 <code class="inline">OUTCAR</code>（或 <code class="inline">OUTCAR.gz</code>）。</li>
        <li><code class="inline">POSCAR</code> 建议使用 <code class="inline">Direct</code> 分数坐标；若为 <code class="inline">Cartesian</code>，请先转换为 <code class="inline">Direct</code>。</li>
        <li>物种顺序（如 <code class="inline">Cs I Pb</code>）在所有帧保持一致，原子总数 <code class="inline">N</code> 不变。</li>
        <li>建议将 <code class="inline">ref0K/</code>、<code class="inline">refVT/</code> 等参考计算放在 <code class="inline">runs/</code> 之外，避免被误识别为帧目录。</li>
      </ul>
    </section>

    <!-- Step 1: 一键脚本 -->
    <section class="card">
      <h2>
        <span class="step">1</span>
        一键生成 7 个 infile.* 文件 <small>统一脚本</small>
      </h2>
      <p>在 <code class="inline">runs/</code> 目录下保存下面脚本为 <code class="inline">tdep_init.py</code>，并赋予执行权限：</p>
      <pre><code># 默认 T=600 K, dt=12500 fs
python tdep_init.py

# 或者指定温度和时间步长
python tdep_init.py --temp 800 --dt-fs 10000</code></pre>
      <p>执行完成后，将生成：</p>
      <ul>
        <li><code class="inline">infile.ssposcar</code> / <code class="inline">infile.ucposcar</code></li>
        <li><code class="inline">infile.positions</code> / <code class="inline">infile.forces</code></li>
        <li><code class="inline">infile.lattice</code> / <code class="inline">infile.meta</code></li>
        <li><code class="inline">infile.stat</code></li>
      </ul>
      <details>
        <summary>展开 / 折叠：tdep_init.py 完整脚本</summary>
        <pre><code>#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
TDEP initialization script (Python only, no LAMMPS dump).

- 自动扫描当前目录下子目录，只要含 POSCAR + OUTCAR/OUTCAR.gz 就认为是一帧
- 用所有帧的 POSCAR 做时间平均，生成 POSCAR_avg_<TEMP>K
- 生成:
    infile.ssposcar  infile.ucposcar
    infile.positions infile.forces
    infile.lattice   infile.meta
    infile.stat
"""

import argparse
import gzip
import os
import re
import sys

from typing import List, Tuple

import numpy as np
from ase.io import read, write
from ase import Atoms


def natural_key(s: str):
    """用于对 frame1, frame2, frame10 做自然排序，而不是字典序"""
    return [int(text) if text.isdigit() else text.lower()
            for text in re.split(r'(\d+)', s)]


def find_frame_dirs() -> List[str]:
    """查找当前目录下所有含 POSCAR + OUTCAR/OUTCAR.gz 的子目录"""
    candidates = []
    for name in os.listdir("."):
        if not os.path.isdir(name):
            continue
        pos = os.path.join(name, "POSCAR")
        out = os.path.join(name, "OUTCAR")
        outgz = os.path.join(name, "OUTCAR.gz")
        if os.path.isfile(pos) and (os.path.isfile(out) or os.path.isfile(outgz)):
            candidates.append(name)

    candidates.sort(key=natural_key)
    return candidates


def read_poscars(frame_dirs: List[str]) -> List[Atoms]:
    images = []
    for d in frame_dirs:
        pos_path = os.path.join(d, "POSCAR")
        try:
            atoms = read(pos_path, format="vasp")
        except Exception as e:
            raise RuntimeError(f"Failed to read {pos_path}: {e}")
        images.append(atoms)
    return images


def build_average_structure(images: List[Atoms], temp_k: float, filename: str) -> Atoms:
    """用分数坐标 + 周期展开，对所有帧做时间平均，并写出 VASP POSCAR"""
    if not images:
        raise RuntimeError("No images to average")

    ref = images[0]
    cell = ref.cell.copy()
    symbols = ref.get_chemical_symbols()

    # 检查每一帧的元素序列是否一致
    for i, img in enumerate(images):
        if img.get_chemical_symbols() != symbols:
            raise RuntimeError(f"Frame {i} symbols mismatch with reference")

    frac_all = np.array([img.get_scaled_positions() for img in images])  # (Nt, N, 3)
    n_frames, n_atoms, _ = frac_all.shape
    print(f"[PY] n_frames = {n_frames}, n_atoms = {n_atoms}")

    # 周期展开
    frac_unwrapped = frac_all.copy()
    for ia in range(n_atoms):
        for ic in range(3):
            x = frac_unwrapped[:, ia, ic]
            dx = np.diff(x)
            dx[dx > 0.5] -= 1.0
            dx[dx < -0.5] += 1.0
            x_unwrap = np.concatenate(([x[0]], x[0] + np.cumsum(dx)))
            frac_unwrapped[:, ia, ic] = x_unwrap

    # 时间平均 + 折回 [0,1)
    frac_mean = frac_unwrapped.mean(axis=0) % 1.0

    avg_atoms = Atoms(symbols=symbols, cell=cell, pbc=True)
    avg_atoms.set_scaled_positions(frac_mean)

    write(filename, avg_atoms, format="vasp", direct=True, vasp5=True)
    print(f"[PY] Average structure written to {filename}")
    return avg_atoms


def open_outcar(path_dir: str):
    outgz = os.path.join(path_dir, "OUTCAR.gz")
    out = os.path.join(path_dir, "OUTCAR")
    if os.path.isfile(outgz):
        return gzip.open(outgz, "rt", errors="ignore")
    elif os.path.isfile(out):
        return open(out, "rt", errors="ignore")
    else:
        raise FileNotFoundError(f"{path_dir} 缺少 OUTCAR/OUTCAR.gz")


def parse_outcar_for_forces_energy_stress(path_dir: str, natoms: int
                                          ) -> Tuple[np.ndarray, float, float, float, float, float, float, float]:
    """
    返回:
      forces: (N,3) in eV/Å
      Ep, Et, Ek, T, P(GPa), sxx..sxz(GPa)
    其中 T 在这里只是占位，用外部传入的 TEMP_K 即可；这里返回的 T=0 占位。
    """
    with open_outcar(path_dir) as f:
        lines = f.readlines()

    # ---- 找最后一个 POSITION ... TOTAL-FORCE 块 ----
    header_indices = [i for i, line in enumerate(lines)
                      if "POSITION" in line and "TOTAL-FORCE" in line]
    if not header_indices:
        raise RuntimeError(f"[{path_dir}] OUTCAR 中找不到 TOTAL-FORCE 块")

    start = header_indices[-1]
    forces = []
    for j in range(start + 2, start + 2 + natoms):
        try:
            cols = lines[j].split()
        except IndexError:
            raise RuntimeError(f"[{path_dir}] TOTAL-FORCE 块长度不足 N={natoms} 行")
        if len(cols) < 3:
            raise RuntimeError(f"[{path_dir}] TOTAL-FORCE 行列数太少: {lines[j].rstrip()}")
        fx, fy, fz = map(float, cols[-3:])
        forces.append([fx, fy, fz])

    forces = np.array(forces)
    if forces.shape != (natoms, 3):
        raise RuntimeError(f"[{path_dir}] forces 形状异常: {forces.shape}, 期望 ({natoms},3)")

    # ---- 能量: energy without entropy / TOTEN ----
    e_val = None
    t_val = None
    for line in lines:
        if "energy  without entropy=" in line:
            parts = line.split()
            # "... energy  without entropy=   <val>  energy(sigma->0)..."
            if len(parts) >= 4:
                try:
                    e_val = float(parts[3])
                except ValueError:
                    pass
        elif "free  energy   TOTEN" in line:
            parts = line.split()
            # "free  energy   TOTEN  =  <val> eV"
            if len(parts) >= 5:
                try:
                    t_val = float(parts[4])
                except ValueError:
                    pass

    if e_val is not None:
        Ep = e_val
    elif t_val is not None:
        Ep = t_val
    else:
        Ep = 0.0  # 退路

    Et = Ep
    Ek = 0.0   # 这里不从 OUTCAR 取动能，保持和原 bash 脚本一致

    # ---- 应力: 最后一个 "in kB" 行 ----
    last_stress_vals = None
    for line in lines:
        if "in kB" in line:
            parts = line.split()
            # 最后 6 项为 xx yy zz xy yz zx (单位 kB)
            if len(parts) >= 6:
                try:
                    vals = list(map(float, parts[-6:]))
                    last_stress_vals = vals
                except ValueError:
                    continue

    if last_stress_vals is None:
        raise RuntimeError(f"[{path_dir}] 无法在 OUTCAR 中找到应力 (in kB)")

    sxx_kB, syy_kB, szz_kB, sxy_kB, syz_kB, sxz_kB = last_stress_vals
    # kB -> GPa: 1 kB = 0.1 GPa
    sxx = sxx_kB * 0.1
    syy = syy_kB * 0.1
    szz = szz_kB * 0.1
    sxy = sxy_kB * 0.1
    syz = syz_kB * 0.1
    sxz = sxz_kB * 0.1

    P = -(sxx + syy + szz) / 3.0

    return forces, Ep, Et, Ek, P, sxx, syy, szz, sxy, syz, sxz


def main():
    parser = argparse.ArgumentParser(
        description="Generate TDEP input files from VASP frames (POSCAR + OUTCAR/OUTCAR.gz)."
    )
    parser.add_argument("--temp", type=float, default=600.0,
                        help="Nominal temperature T(K) for infile.meta/stat (default: 600)")
    parser.add_argument("--dt-fs", type=float, default=12500.0,
                        help="Time interval between frames in fs (default: 12500)")
    args = parser.parse_args()

    TEMP_K = args.temp
    DT_FS = args.dt_fs

    print(f"[info] T (meta/stat) = {TEMP_K} K")
    print(f"[info] Δt (meta/stat)= {DT_FS} fs\n")

    # 1) 查找帧目录
    frame_dirs = find_frame_dirs()
    if not frame_dirs:
        print("[ERR] 当前目录下没有找到任何同时包含 POSCAR 和 OUTCAR(或 OUTCAR.gz) 的 VASP 计算目录")
        sys.exit(1)

    print("[info] 识别到的帧目录：", " ".join(frame_dirs))
    Nt = len(frame_dirs)
    print(f"[info] Nt (frames)   = {Nt}\n")

    # 2) 读 POSCAR，构造平均结构
    images = read_poscars(frame_dirs)
    N = len(images[0])
    print(f"[info] N (atoms)     = {N}\n")

    avg_poscar_name = f"POSCAR_avg_{int(TEMP_K)}K"
    avg_atoms = build_average_structure(images, TEMP_K, avg_poscar_name)

    # 3) 写 infile.ssposcar / infile.ucposcar
    write("infile.ssposcar", avg_atoms, format="vasp", direct=True, vasp5=True)
    write("infile.ucposcar", avg_atoms, format="vasp", direct=True, vasp5=True)
    print("[OK] infile.ssposcar / infile.ucposcar\n")

    # 4) 生成 infile.positions (ASE 直接拿分数坐标，避免手动解析 Direct/Cartesian)
    print("[info] building infile.positions ...")
    with open("infile.positions", "w") as f_pos:
        for atoms in images:
            if len(atoms) != N:
                raise RuntimeError("All frames must have the same number of atoms")
            frac = atoms.get_scaled_positions()
            for xyz in frac:
                f_pos.write(f"{xyz[0]:.10f} {xyz[1]:.10f} {xyz[2]:.10f}\n")
    print("[OK] infile.positions\n")

    # 5) 生成 infile.lattice (每帧 3 行晶格向量)
    print("[info] building infile.lattice ...")
    with open("infile.lattice", "w") as f_lat:
        for atoms in images:
            cell = atoms.cell  # 3x3
            for v in cell:
                f_lat.write(f"{v[0]:.10f} {v[1]:.10f} {v[2]:.10f}\n")
    print("[OK] infile.lattice\n")

    # 6) 生成 infile.forces & 中途收集 stat 所需信息
    print("[info] building infile.forces & collecting stat info ...")
    all_forces = []
    stat_records = []  # (Ep, Et, Ek, P, sxx, syy, szz, sxy, syz, sxz)

    for d in frame_dirs:
        forces, Ep, Et, Ek, P, sxx, syy, szz, sxy, syz, sxz = parse_outcar_for_forces_energy_stress(d, N)
        all_forces.append(forces)
        stat_records.append((Ep, Et, Ek, P, sxx, syy, szz, sxy, syz, sxz))

    with open("infile.forces", "w") as f_for:
        for forces in all_forces:
            for fx, fy, fz in forces:
                f_for.write(f"{fx:.10f} {fy:.10f} {fz:.10f}\n")
    print("[OK] infile.forces\n")

    # 7) 生成 infile.meta
    with open("infile.meta", "w") as f_meta:
        f_meta.write(f"{N:d}\n")
        f_meta.write(f"{Nt:d}\n")
        f_meta.write(f"{DT_FS:.1f}\n")
        f_meta.write(f"{TEMP_K:.1f}\n")
    print("[OK] infile.meta\n")

    # 8) 生成 infile.stat
    print("[info] building infile.stat ...")
    with open("infile.stat", "w") as f_stat:
        for i, (Ep, Et, Ek, P, sxx, syy, szz, sxy, syz, sxz) in enumerate(stat_records, start=1):
            t_fs = (i - 1) * DT_FS
            Tval = TEMP_K
            # 与原 bash 脚本格式对应: i t_fs Et Ep Ek T P sxx syy szz sxy syz sxz
            line = (
                f"{i:d} "
                f"{t_fs:.1f} "
                f"{Et:.10f} "
                f"{Ep:.10f} "
                f"{Ek:.6f} "
                f"{Tval:.1f} "
                f"{P:.6f} "
                f"{sxx:.6f} "
                f"{syy:.6f} "
                f"{szz:.6f} "
                f"{sxy:.6f} "
                f"{syz:.6f} "
                f"{sxz:.6f}\n"
            )
            f_stat.write(line)

    # 简单列数检查
    with open("infile.stat", "r") as f_stat:
        for lineno, line in enumerate(f_stat, start=1):
            if not line.strip():
                continue
            nf = len(line.split())
            if nf != 13:
                raise RuntimeError(f"infile.stat 第 {lineno} 行列数={nf} ≠ 13")
    print("[OK] infile.stat 列数OK(13)\n")

    # 9) 简单一致性检查
    def count_lines(fname: str) -> int:
        with open(fname, "r") as f:
            return sum(1 for _ in f)

    n_pos = count_lines("infile.positions")
    n_for = count_lines("infile.forces")
    n_lat = count_lines("infile.lattice")

    print(f"[check] positions 行数 = {n_pos} (应为 N*Nt={N*Nt})")
    print(f"[check] forces    行数 = {n_for} (应为 N*Nt={N*Nt})")
    print(f"[check] lattice   行数 = {n_lat} (应为 3*Nt={3*Nt})")

    if n_pos != N * Nt:
        raise RuntimeError("infile.positions 行数不等于 N*Nt")
    if n_for != N * Nt:
        raise RuntimeError("infile.forces 行数不等于 N*Nt")
    if n_lat != 3 * Nt:
        raise RuntimeError("infile.lattice 行数不等于 3*Nt")

    print("\n[DONE] TDEP 所需 7 个文件已全部生成：")
    print("       infile.ssposcar  infile.ucposcar")
    print("       infile.positions infile.forces")
    print("       infile.lattice   infile.meta")
    print("       infile.stat")


if __name__ == "__main__":
    main()
</code></pre>
      </details>
    </section>

    <!-- Step 2: 打包为 outfile.sim.hdf5 -->
    <section class="card">
      <h2>
        <span class="step">2</span>
        打包为 outfile.sim.hdf5
      </h2>
      <p>在生成 7 个 <code class="inline">infile.*</code> 后，在同一目录执行：</p>
      <pre><code>pack_simulation -npt --temperature 600</code></pre>
      <p>会生成 <code class="inline">outfile.sim.hdf5</code>，供后续 <code class="inline">extract_forceconstants</code> 等 TDEP 程序使用。</p>
    </section>

    <!-- Step 3: FC2 拟合与声子 DOS -->
    <section class="card">
      <h2>
        <span class="step">3</span>
        拟合 FC2 并计算声子 DOS
      </h2>
      <ol>
        <li>拟合 600 K 有效二阶力常数（FC2）：</li>
      </ol>
      <pre><code>extract_forceconstants -rc2 7.0</code></pre>
      <ol start="2">
        <li>计算声子 DOS 与 600 K 热力学量：</li>
      </ol>
      <pre><code>ln -sf outfile.forceconstant infile.forceconstant
phonon_dispersion_relations --dos --qpoint_grid 18 18 18 --unit mev | tee log.ph</code></pre>
    </section>

    <!-- Step 4: 计算 Fvib -->
    <section class="card">
      <h2>
        <span class="step">4</span>
        计算 F<sub>vib</sub>(T)（以 600 K 为例）
      </h2>
      <p>将下列脚本保存为 <code class="inline">calc_Fvib_600K.sh</code>，默认读取 <code class="inline">outfile.phonon_dos</code> 与 <code class="inline">infile.ssposcar</code>：</p>
      <details>
        <summary>展开 / 折叠 calc_Fvib_600K.sh</summary>
        <pre><code>
#!/bin/bash
# 计算 TDEP 输出 outfile.phonon_dos 的 F_vib(T) （默认 T=600 K）
# 用 infile.ssposcar 第 7 行的原子数求 N，再用 DOS 做数值积分
# 用法：
#   bash calc_Fvib_600K.sh            # 默认读 outfile.phonon_dos, T=600K
#   bash calc_Fvib_600K.sh dosfile T  # 自定义 DOS 文件和温度

dosfile=${1:-outfile.phonon_dos}
T=${2:-600}
ssposcar=infile.ssposcar

if [ ! -f "$dosfile" ]; then
  echo "ERROR: 找不到 DOS 文件: $dosfile"
  exit 1
fi

if [ ! -f "$ssposcar" ]; then
  echo "ERROR: 找不到结构文件: $ssposcar (用来读原子数 N)"
  exit 1
fi

# 从 infile.ssposcar 第 7 行把所有元素个数加起来 -> N
N=$(awk 'NR==7{for(i=1;i<=NF;i++) s+=$i; print s}' "$ssposcar")

echo "使用 DOS 文件: $dosfile"
echo "使用结构文件: $ssposcar"
echo "原子总数 N = $N"
echo "温度 T = $T K"

awk -v N="$N" -v T="$T" '
BEGIN{
  # k_B in meV/K (1 eV = 1000 meV)
  kB = 8.617333262e-2
  kT = kB*T
  eps = 1e-20

  print "-----------------------------------------------"
  print "Integrating F_vib from " ARGV[1]
  print "T = " T " K, kT = " kT " meV"
  print "-----------------------------------------------"
}

# 跳过注释行，只要有两列以上的数：E(meV)  DOS(E)
$1 !~ /^#/ && NF >= 2 {
  E = $1
  D = $2

  # 第一行只做初始化
  if (++i == 1) {
    pE = E
    pD = D
    next
  }

  dE = E - pE

  # 只在区间两端都 >0 的时候积分（丢掉虚频区间）
  if (E > 0 && pE > 0) {
    # 对纯 DOS 积分：梯形法
    Davg = 0.5*(D + pD)
    area += Davg * dE

    # 对 D(E)*f(E) 积分：也用梯形法，但要对 D*f 做
    f1 = 0.5*pE + kT*log(1 - exp(-pE/kT) + eps)  # F(pE)
    f2 = 0.5*E  + kT*log(1 - exp(-E /kT) + eps)  # F(E)

    # 梯形：∫ D(E)F(E)dE ≈ 0.5 * (D1*F1 + D2*F2) * dE
    Fsum += 0.5*(pD*f1 + D*f2) * dE
  }

  # 标记是否有负频（虚频）
  if (E < 0 || pE < 0) neg = 1

  pE = E
  pD = D
}

END{
  if (area <= 0) {
    print "ERROR: 没有正能量区间可积（area <= 0），检查 DOS 或虚频情况。"
    exit 1
  }

  modes = 3.0 * N          # 一共 3N 个声子模
  scale = modes / area     # 把 DOS 归一化到 3N

  F_cell_meV = scale * Fsum        # meV/小胞
  F_cell_eV  = F_cell_meV / 1000.0
  F_atom_eV  = F_cell_eV / N

  print ""
  printf("positive-area(raw) = %.6f (meV)\n", area)
  printf("scale factor       = %.6f (target modes = %.1f)\n", scale, modes)
  print "-----------------------------------------------"
  printf("F_vib(T=%.1f K) = %.6f eV/atom\n", T, F_atom_eV)
  printf("F_vib(T=%.1f K) = %.6f eV/cell  (N = %d)\n",
         T, F_cell_eV, N)
  print "-----------------------------------------------"

  if (neg) {
    print "Note: 检测到虚频(负能量)，只对 E>0 区间做积分并重归一化到 3N 模。"
    print "      结果为近似值，建议以后在改进力常数/去虚频后再对比一次。"
  }
}
' "$dosfile"
        </code></pre>
      </details>
    </section>

    <div class="footer">
      TDEP 打包与后处理手册（统一脚本版） · 可直接放入工程项目中复用
    </div>
  </div>
</body>
</html>
